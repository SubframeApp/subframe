---
title: Using components
description: Add and configure components in Subframe, then use them in your React code.
---

Add components to the canvas, configure instances in Subframe, then import and use them in your React application.

## Adding components

Add components from the component library, command palette, or Ask AI. For detailed instructions, see [Add Elements](/editor/design-mode/add-elements#components).

## Component instances

When you add a component to your canvas, you create an **instance**. The component is a definition, the instance is a specific use.

An instance can be configured independently. Change text, icon, or color without affecting other instances. When the component definition changes—like a bug fix or style update—all instances update.

**Example:**
- The **Button component** defines how buttons look and behave
- Each **Button instance** can have different text and colors
- Update the Button component's hover state → all instances get the new hover behavior

### Instance properties

Configure in the Inspector panel:

- **Text content** - Button labels, headings, descriptions
- **Icons** - Choose from icon libraries
- **Variants** - Switch between size, color, or style options
- **Boolean toggles** - Show/hide elements, enable/disable states
- **Images** - Upload or link to images
- **Slots** - Custom content areas

## Configuring components

Select an instance to see properties in the Inspector panel.

**Text properties** - Click into fields to edit content. Text exports as children or named prop.

**Variant properties** - Use dropdowns to switch between pre-configured variants. Variants bundle multiple style properties.

**Boolean properties** - Toggle switches enable or disable features. Control visibility and behavior.

**Icon properties** - Click picker to search and select icons. Supports Feather Icons, Lucide, Font Awesome.

**Slot properties** - Click **Edit slot contents** to customize. Slots let you nest components inside other components.

**Image properties** - Paste URL or upload file. Use placeholders during design, real URLs in code.

## Overriding instance styles

Override when an instance needs unique styling for prototyping or one-off variations.

1. Select the instance
2. Modify style properties (colors, spacing, borders)
3. Overridden properties show **purple indicator**

Overrides are instance-specific and don't affect other instances or the component definition.

**Reset overrides:** Click purple indicator to revert to default, or right-click → **Reset all overrides**.

## Detaching instances

Detaching breaks the connection between instance and component. The instance becomes a regular group of elements.

**When to detach:**
- Complete redesign needed for this specific instance
- Instance should never update with the component
- Creating one-off design that won't be reused

**How to detach:**
1. Right-click instance
2. Select **Detach instance**
3. Instance becomes editable group

**After detaching:**
- Instance no longer updates when component changes
- Can edit any internal element directly
- Cannot be re-attached
- No longer has component props or variants

<Warning>
Detach sparingly. Detached instances lose consistency, updates, and reusability. Use variants or overrides instead.
</Warning>

## Component documentation

Every component has built-in documentation.

1. Click **Components** tab in top navigation
2. Select a component
3. View documentation panel:
   - Props with descriptions and types
   - Variants with preview images
   - Examples with copyable code
   - Source code for React component

<video autoPlay muted loop playsInline controls className="w-full" src="https://hevpkratkeuc60w7.public.blob.vercel-storage.com/view-component-documentation-ygcEi4y47JotWdboZUunSHbkxdpYrh.webm" />

Interactive examples show common use cases. Click **View code** to see implementation and copy to clipboard.

## Using in code

After syncing with `npx @subframe/cli sync`, components are ready to use in your React application.

### Importing

Import using the alias configured during installation:

```tsx src/App.tsx
import { Button } from "@/ui/Button"
import { TextField } from "@/ui/TextField"
import { Alert } from "@/ui/Alert"
```

### Props and events

Use components like any React component:

```tsx
<Button
  variant="brand-primary"
  size="medium"
  icon="FeatherCheck"
  onClick={() => handleSubmit()}
  disabled={isLoading}
>
  Submit
</Button>
```

All props are TypeScript-typed. Subframe components forward standard React props like `onClick` and `disabled` to their root element.

### Slots

Components with slots accept React elements:

```tsx
<Alert
  icon="FeatherInfo"
  title="Update available"
  actions={<Button onClick={() => install()}>Install now</Button>}
>
  A new version is ready to install.
</Alert>
```

The default slot uses `children`. See [Props and Slots](/components/props-and-slots) for details.

### Wrapper components

Wrap Subframe components with custom logic instead of modifying generated files. Wrappers keep components synced while adding functionality.

```tsx LoginButton.tsx
'use client'
import { useState } from 'react'
import { Button } from '@/ui/Button'

export function LoginButton() {
  const [isLoading, setIsLoading] = useState(false)

  async function handleLogin() {
    setIsLoading(true)
    try {
      await loginUser()
      redirect('/dashboard')
    } catch (error) {
      showError(error)
    } finally {
      setIsLoading(false)
    }
  }

  return (
    <Button onClick={handleLogin} disabled={isLoading}>
      {isLoading ? 'Logging in...' : 'Log in'}
    </Button>
  )
}
```

<Tip>
Wrapper components are the recommended pattern when you need to add business logic. This keeps generated Subframe files untouched and prevents conflicts during sync.
</Tip>

For more examples, see [Adding Business Logic](/developing/adding-business-logic).

## Troubleshooting

<AccordionGroup>
<Accordion title="Instance not updating">

If instance doesn't reflect component changes:

1. Check if properties are overridden (purple indicators in Inspector)
2. Reset overrides to get latest component styles
3. If detached, instance won't update—replace with new instance

</Accordion>
<Accordion title="Component not rendering in app">

If component doesn't appear in your React app:

1. Sync components: `npx @subframe/cli sync --all`
2. Check import path matches CLI configuration
3. Restart dev server after syncing
4. Check for TypeScript errors in IDE

</Accordion>
<Accordion title="Props not working in code">

If props don't work:

1. Check component documentation for correct prop name
2. Verify prop value matches TypeScript types
3. Sync again: `npx @subframe/cli sync ComponentName`

</Accordion>
</AccordionGroup>

