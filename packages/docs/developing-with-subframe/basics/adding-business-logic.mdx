---
title: Adding business logic
icon: timeline
description: "Get your components to not only look good, but also do things"
---

Since Subframe components are just React components, you can use them like any other React component. You can pass props to them, and they will work just like any other React component.

## The basics

Generally, when we add business logic to components that are designed in Subframe, we don't generally directly change any code in our `src/ui/` directory. Instead, we import the components into our app and hook up business logic there.

Subframe components are built on top of Radix UI, which means that they are accessible by default. They also expose all event handlers that the underlying HTML elements take. This means that you can use the `onClick`, `onChange`, and other event handlers to add business logic to your components.

## Examples

For the next few examples, let's imagine we're building the next music streaming service called Spoofy.

<Tip>
  We've made a CodeSandbox project for the examples below so you can play around with the code. You can find it
  [here](https://codesandbox.io/p/devbox/subframe-spoofy-rw5wrj).
</Tip>

### Example 1 - A simple form

Of course for our app, we'll need to implement some form of login. Magic link logins seem to be a popular choice these days, so let's build a simple magic link login form.

This is what we want the end-result to look like:

<img
  src="/images/developing-with-subframe/basics/adding-business-logic/form-example-1.png"
  alt="Form Example 1"
  className="w-full"
/>

Adding business logic to your app is as simple as providing the necessary props to your Subframe components.

Now, let's add some functionality to our design.
We'll add a fake fetch function that simulates a network request and a `handleSubmit` function that handles the form submission.

We also want our Button component to show that we're currently submitting the form, so we'll keep `submitting` in a state variable and pass it to the Button component in the `disabled` and `loading` prop.

You can see the changes we made to the components in the highlighted lines below.

<CodeGroup>

```tsx src/App.tsx (without business logic)
import { DialogLayout } from "@/ui/layouts/DialogLayout"
import { TextField } from "@/ui/components/TextField"
import { Button } from "@/ui/components/Button"

function App() {
  return (
    <DialogLayout open={true}>
      <div className="flex h-full w-full flex-col items-center gap-6 bg-default-background px-6 py-12">
        <span className="text-heading-2 font-heading-2 text-default-font">Magic Link Login</span>
        <form className="flex w-full flex-col items-start gap-2">
          <TextField className="h-auto w-full flex-none" label="Email">
            <TextField.Input required name="name" />
          </TextField>
          <Button
            type="submit"
            className="h-8 w-full flex-none"
            variant="brand-secondary"
            icon="FeatherSend"
            iconRight={null}
            disabled={false}
            loading={false}
          >
            Send Magic Link
          </Button>
        </form>
      </div>
    </DialogLayout>
  )
}

export default App
```

```tsx src/App.tsx (with business logic) {4, 6-15, 18, 20-32, 49-50}
import { DialogLayout } from "@/ui/layouts/DialogLayout"
import { TextField } from "@/ui/components/TextField"
import { Button } from "@/ui/components/Button"
import { useState, type FormEvent } from "react"

const fakeFetch = (email: string | undefined) => {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      if (!email) {
        reject(new Response("Email is required", { status: 400 }))
      }
      resolve(new Response("Success!", { status: 200 }))
    }, 1000)
  })
}

function App() {
  const [submitting, setSubmitting] = useState(false)

  async function handleSubmit(e: FormEvent<HTMLFormElement>) {
    e.preventDefault()
    setSubmitting(true)
    const formData = new FormData(e.currentTarget)
    const email = formData.get("email")?.toString()
    try {
      await fakeFetch(email)
    } catch (e) {
      console.error(e)
    } finally {
      setSubmitting(false)
    }
  }

  return (
    <DialogLayout open={true}>
      <div className="flex h-full w-full flex-col items-center gap-6 bg-default-background px-6 py-12">
        <span className="text-heading-2 font-heading-2 text-default-font">Magic Link Login</span>
        <form onSubmit={handleSubmit} className="flex w-full flex-col items-start gap-2">
          <TextField className="h-auto w-full flex-none" label="Email" icon={null} iconRight={null}>
            <TextField.Input required name="name" />
          </TextField>
          <Button
            type="submit"
            className="h-8 w-full flex-none"
            variant="brand-secondary"
            size="medium"
            icon="FeatherSend"
            iconRight={null}
            disabled={submitting}
            loading={submitting}
          >
            Send Magic Link
          </Button>
        </form>
      </div>
    </DialogLayout>
  )
}

export default App
```

</CodeGroup>

All these changes now result in the following:

<video
  autoPlay
  muted
  loop
  playsInline
  className="w-full"
  src="/images/developing-with-subframe/basics/adding-business-logic/form-example-2.webm"
/>

### Example 2 - A complex custom component

Now let's imagine we'd like to build a feature where we show the user their most-listened-to tracks of the past week and want to allow them to favorite them so they can easily find them later.

We've built this component in Subframe:

![Component Example Page](/images/developing-with-subframe/basics/adding-business-logic/component-example-page.png)

Now let's add some business logic to it!

First, we'll create our component with business logic. Remember that we don't want to change the Subframe component's code directly, so we'll create a new component that wraps the Subframe component and adds our business logic to it.

Then, we'll create a wrapper component that keeps track of the favorite state and handles the click event.

<CodeGroup>

```tsx src/components/TrackCard.tsx
import { HTMLAttributes, useMemo } from "react"
import { TrackCard as SubframeTrackCard } from "@/ui"
import { Image } from "./Image"

export interface TrackCardProps extends HTMLAttributes<HTMLDivElement> {
  title: string
  artist: string
  length: number // in seconds
  genre: string
  coverImage: string
  isFavorite: boolean
  onFavoriteClick: () => void
}

function lengthToString(length: number): string {
  const minutes = Math.floor(length / 60)
  const seconds = length % 60
  return `${minutes.toString().padStart(2, "0")}:${seconds.toString().padStart(2, "0")}`
}

const TrackCard = ({ title, artist, length, genre, coverImage, isFavorite, onFavoriteClick }: TrackCardProps) => {
  // Convert track length in seconds to MM:SS format
  const formattedLength = useMemo(() => lengthToString(length), [length])
  // Determine the icon based on favorite status
  const icon = useMemo(() => (isFavorite ? "FeatherHeartOff" : "FeatherHeart"), [isFavorite])

  return (
    <SubframeTrackCard
      title={title}
      artist={artist}
      length={formattedLength}
      favoriteButtonSlot={<SubframeTrackCard.FavoriteButton icon={icon} onClick={onFavoriteClick} />}
      imageSlot={<Image src={coverImage} width={500} height={500} />}
      genre={genre}
    />
  )
}

export default TrackCard
```

```tsx src/components/FavoriteTracks.tsx
import { useState } from "react"
import TrackCardWithLogic from "../components/TrackCard"

interface Track {
  id: number
  title: string
  artist: string
  length: number // in seconds
  genre: string
  coverImage: string
  isFavorite: boolean
}

const FavoriteTracks = () => {
  const [tracks, setTracks] = useState<Track[]>([
    {
      id: 1,
      title: "The Less I Know The Better",
      artist: "Tame Impala",
      length: 218,
      genre: "Disco",
      coverImage: "/covers/tame_impala-currents.jpg",
      isFavorite: false,
    },
    {
      id: 2,
      title: "Shadowplay",
      artist: "Joy Division",
      length: 233,
      genre: "Post Punk",
      coverImage: "/covers/joy_division-unknown-pleasures.jpg",
      isFavorite: false,
    },
    {
      id: 3,
      title: "Bohemian Rhapsody",
      artist: "Queen",
      length: 355,
      genre: "Progressive Rock",
      coverImage: "/covers/queen-bohemian_rhapsody.jpg",
      isFavorite: false,
    },
  ])

  const handleFavoriteClick = (id: number) => {
    setTracks((prevTracks) =>
      prevTracks.map((track) => (track.id === id ? { ...track, isFavorite: !track.isFavorite } : track)),
    )
  }

  return (
    <div className="flex flex-col gap-4">
      <span className="text-heading-1 font-heading-1 text-default-font">Your favorite tracks of the week</span>
      <div className="flex flex-row gap-4">
        {tracks.map((track) => (
          <TrackCardWithLogic
            key={track.id}
            title={track.title}
            artist={track.artist}
            length={track.length}
            genre={track.genre}
            coverImage={track.coverImage}
            isFavorite={track.isFavorite}
            onFavoriteClick={() => handleFavoriteClick(track.id)}
          />
        ))}
      </div>
    </div>
  )
}

export default FavoriteTracks
```

</CodeGroup>

And we're done! The end result looks like this:

<video
  autoPlay
  muted
  loop
  playsInline
  className="w-full aspect-video"
  src="/images/developing-with-subframe/basics/adding-business-logic/component-example-2.webm"
/>

You may have noticed that we're using slots for our image and favorite button. We'll cover the reasons for this in the next page.
